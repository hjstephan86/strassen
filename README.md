# strassen
This is a simple Python project implementing the Strassen algorithm and required data structures. It also provides some documentation theory inside doc/. Experiments were conducted for original matrix multiplication in comparison to Strassen matrix multiplication. Interesting to observe that the first $n_0$ for which Strassen is faster than the original multiplication is $n = 132$ (Ubuntu 24.04.2. LTS, AMD Ryzen 5 7520U Ã— 8 with 4384.00 MHz, RAM: 7.01 GB). Have a look at the plot of the experimental results:

![Performance Comparison: Standard vs. Strassen Matrix Multiplication](strassen_performance_comparison.svg)

For $n = 56$ both the original and Strassen's multiplication ran faster than for previous $n < 56 = 7 \cdot 8$. Strassen uses 7 matrix multiplications, i.e., 14 sub-matrices. What if 15 sub-matrices or structures are used for a faster matrix multiplication than Strassen's? The idea is to find 15 (sub-)structures in the two $n \times n$ matrices to improve Strassen's running time. Consider the diagonal of matrix B to obtain only 6 matrix multiplications instead of 7. Combine $P_2$ and $P_5$ into $P_{25}$, which each use the diagonal elements $B_{11}$ and $B_{22}$ of matrix $B$ for multiplication, thus achieving a running time in the exponent of $n$ of 2.585 instead of 2.807.

In general, for this specific Python implementation, with STRASSEN_INTERNAL_THRESHOLD set to 32, Strassen does not provide a performance benefit over standard matrix multiplication within the tested range of $n = 4$ to $n = 256$. The overhead associated with recursive calls, matrix splitting/joining, and especially the padding for non-power-of-two dimensions, makes it consistently slower. To observe Strassen's potential advantage, the experiment might need to test larger $n$ values (e.g., $n = 512,1024,2048, \ldots $). <span style="color: green;">Side note: when starting experiment conduction there was a cross for</span> $n = 256$<span style="color: green;">, but during 5 experiment repititions no further cross was observed (Python got warm ;).</span>